package model

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/open-telemetry/opamp-go/protobufs"
	"gopkg.in/yaml.v3"

	"github.com/minuk-dev/opampcommander/internal/domain/model/agent"
	"github.com/minuk-dev/opampcommander/internal/domain/model/vo"
)

// Agent is a domain model to control opamp agent by opampcommander.
type Agent struct {
	Metadata AgentMetadata
	Spec     AgentSpec
	Commands AgentCommands
	Status   AgentStatus
}

// NewAgent creates a new agent with the given instance UID.
// It initializes all fields with default values.
// You can optionally pass AgentOption functions to customize the agent.
func NewAgent(instanceUID uuid.UUID, opts ...AgentOption) *Agent {
	agent := &Agent{
		//exhaustruct:ignore
		Metadata: AgentMetadata{
			InstanceUID: instanceUID,
		},
		Spec: AgentSpec{
			RemoteConfig: NewRemoteConfig(),
		},
		Status: AgentStatus{
			EffectiveConfig: AgentEffectiveConfig{
				ConfigMap: AgentConfigMap{
					ConfigMap: make(map[string]AgentConfigFile),
				},
			},
			//exhaustruct:ignore
			PackageStatuses: AgentPackageStatuses{
				Packages: make(map[string]AgentPackageStatus),
			},
			//exhaustruct:ignore
			ComponentHealth: AgentComponentHealth{
				StartTime:          time.Now(),
				ComponentHealthMap: make(map[string]AgentComponentHealth),
			},
			//exhaustruct:ignore
			AvailableComponents: AgentAvailableComponents{
				Components: make(map[string]ComponentDetails),
			},
			Conditions: []AgentCondition{
				{
					Type:               AgentConditionTypeRegistered,
					LastTransitionTime: time.Now(),
					Status:             AgentConditionStatusTrue,
					Reason:             "system",
					Message:            "Agent registered",
				},
			},
			Connected:      false,
			ConnectionType: ConnectionTypeUnknown,
			LastReportedAt: time.Time{},
			LastReportedTo: nil,
		},
		Commands: AgentCommands{
			Commands: []AgentCommand{},
		},
	}

	// Apply options
	for _, opt := range opts {
		opt(agent)
	}

	return agent
}

// IsConnected checks if the agent is currently connected.
func (a *Agent) IsConnected(_ context.Context) bool {
	return !a.Status.LastReportedAt.IsZero()
}

// HasPendingServerMessages checks if there are any pending server messages for the agent.
func (a *Agent) HasPendingServerMessages() bool {
	return len(a.Commands.Commands) > 0
}

// ConnectedServerID returns the server the agent is currently connected to.
func (a *Agent) ConnectedServerID() (*Server, error) {
	return a.Status.LastReportedTo, nil
}

// AgentOption is a function that configures an Agent.
type AgentOption func(*Agent)

// WithDescription sets the agent description.
func WithDescription(description *agent.Description) AgentOption {
	return func(a *Agent) {
		if description != nil {
			a.Metadata.Description = *description
		}
	}
}

// WithCapabilities sets the agent capabilities.
func WithCapabilities(capabilities *agent.Capabilities) AgentOption {
	return func(a *Agent) {
		if capabilities != nil {
			a.Metadata.Capabilities = *capabilities
		}
	}
}

// WithCustomCapabilities sets the agent custom capabilities.
func WithCustomCapabilities(customCapabilities *AgentCustomCapabilities) AgentOption {
	return func(a *Agent) {
		if customCapabilities != nil {
			a.Metadata.CustomCapabilities = *customCapabilities
		}
	}
}

// WithEffectiveConfig sets the agent effective config.
func WithEffectiveConfig(effectiveConfig *AgentEffectiveConfig) AgentOption {
	return func(a *Agent) {
		if effectiveConfig != nil {
			a.Status.EffectiveConfig = *effectiveConfig
		}
	}
}

// WithComponentHealth sets the agent component health.
func WithComponentHealth(componentHealth *AgentComponentHealth) AgentOption {
	return func(a *Agent) {
		if componentHealth != nil {
			a.Status.ComponentHealth = *componentHealth
		}
	}
}

// WithPackageStatuses sets the agent package statuses.
func WithPackageStatuses(packageStatuses *AgentPackageStatuses) AgentOption {
	return func(a *Agent) {
		if packageStatuses != nil {
			a.Status.PackageStatuses = *packageStatuses
		}
	}
}

// WithAvailableComponents sets the agent available components.
func WithAvailableComponents(availableComponents *AgentAvailableComponents) AgentOption {
	return func(a *Agent) {
		if availableComponents != nil {
			a.Status.AvailableComponents = *availableComponents
		}
	}
}

// WithRemoteConfigStatus sets the agent remote config status.
func WithRemoteConfigStatus(remoteConfigStatus *AgentRemoteConfigStatus) AgentOption {
	return func(agent *Agent) {
		if remoteConfigStatus != nil {
			if remoteConfigStatus.ErrorMessage != "" {
				agent.Spec.RemoteConfig.SetLastErrorMessage(remoteConfigStatus.ErrorMessage)
			}

			agent.Spec.RemoteConfig.SetStatus(
				vo.Hash(remoteConfigStatus.LastRemoteConfigHash),
				remoteConfigStatus.Status,
			)
		}
	}
}

// AgentMetadata is a domain model to control opamp agent metadata.
type AgentMetadata struct {
	// InstanceUID is a unique identifier for the agent instance.
	// It is generated by the agent and should not change between restarts of the agent.
	InstanceUID uuid.UUID

	// Description is a agent description defined in the opamp protocol.
	// It is set by the agent and should not change between restarts of the agent.
	// It can be changed by the agent at any time.
	Description agent.Description

	// Capabilities is a agent capabilities defined in the opamp protocol.
	Capabilities agent.Capabilities

	// CustomCapabilities is a list of custom capabilities that the Agent supports.
	CustomCapabilities AgentCustomCapabilities
}

// IsComplete checks if all required metadata fields are populated.
// Returns true if the agent has reported its description and capabilities.
func (am *AgentMetadata) IsComplete() bool {
	// Check if Description has any attributes
	hasDescription := len(am.Description.IdentifyingAttributes) > 0 ||
		len(am.Description.NonIdentifyingAttributes) > 0

	// Check if Capabilities is not zero (unset)
	hasCapabilities := am.Capabilities != 0

	return hasDescription && hasCapabilities
}

// AgentStatus is a domain model to control opamp agent status.
type AgentStatus struct {
	EffectiveConfig     AgentEffectiveConfig
	PackageStatuses     AgentPackageStatuses
	ComponentHealth     AgentComponentHealth
	AvailableComponents AgentAvailableComponents

	// Conditions is a list of conditions that apply to the agent.
	Conditions []AgentCondition

	Connected      bool
	ConnectionType ConnectionType
	LastReportedAt time.Time
	LastReportedTo *Server
}

// AgentCondition represents a condition of an agent.
type AgentCondition struct {
	// Type is the type of the condition.
	Type AgentConditionType
	// LastTransitionTime is the last time the condition transitioned.
	LastTransitionTime time.Time
	// Status is the status of the condition.
	Status AgentConditionStatus
	// Reason is the identifier of the user or system that triggered the condition.
	Reason string
	// Message is a human readable message indicating details about the condition.
	Message string
}

// AgentConditionType represents the type of an agent condition.
type AgentConditionType string

const (
	// AgentConditionTypeConnected represents the condition when the agent is connected.
	AgentConditionTypeConnected AgentConditionType = "Connected"
	// AgentConditionTypeHealthy represents the condition when the agent is healthy.
	AgentConditionTypeHealthy AgentConditionType = "Healthy"
	// AgentConditionTypeConfigured represents the condition when the agent has been configured.
	AgentConditionTypeConfigured AgentConditionType = "Configured"
	// AgentConditionTypeRegistered represents the condition when the agent has been registered.
	AgentConditionTypeRegistered AgentConditionType = "Registered"
)

// AgentConditionStatus represents the status of an agent condition.
type AgentConditionStatus string

const (
	// AgentConditionStatusTrue represents a true condition status.
	AgentConditionStatusTrue AgentConditionStatus = "True"
	// AgentConditionStatusFalse represents a false condition status.
	AgentConditionStatusFalse AgentConditionStatus = "False"
	// AgentConditionStatusUnknown represents an unknown condition status.
	AgentConditionStatusUnknown AgentConditionStatus = "Unknown"
)

// AgentCommands is a list of commands to be sent to the agent.
type AgentCommands struct {
	Commands []AgentCommand
}

// Clear removes all commands and returns them.
func (ac *AgentCommands) Clear() []AgentCommand {
	commands := ac.Commands
	ac.Commands = []AgentCommand{}

	return commands
}

// SendReportFullState adds a ReportFullState command to the commands list.
func (ac *AgentCommands) SendReportFullState(reportFullState bool, requestedAt time.Time, requestedBy string) {
	ac.Commands = append(ac.Commands, AgentCommand{
		CommandID:               uuid.New(),
		ReportFullState:         reportFullState,
		RemoteConfigUpdated:     false,
		RemoteConfigUpdatedHash: vo.Hash{},
		CreatedAt:               requestedAt,
		CreatedBy:               requestedBy,
	})
}

// SendRemoteConfigUpdated adds a RemoteConfigUpdated command to the commands list.
func (ac *AgentCommands) SendRemoteConfigUpdated(configHash vo.Hash, requestedAt time.Time, requestedBy string) {
	ac.Commands = append(ac.Commands, AgentCommand{
		CommandID:               uuid.New(),
		ReportFullState:         false,
		RemoteConfigUpdated:     true,
		RemoteConfigUpdatedHash: configHash,
		CreatedAt:               requestedAt,
		CreatedBy:               requestedBy,
	})
}

// HasReportFullStateCommand checks if there's any ReportFullState command.
func (ac *AgentCommands) HasReportFullStateCommand() bool {
	for _, cmd := range ac.Commands {
		if cmd.ReportFullState {
			return true
		}
	}

	return false
}

// AgentCommand is a domain model to control opamp agent commands.
type AgentCommand struct {
	// CommandID is a unique identifier for the command.
	CommandID uuid.UUID
	// ReportFullState is a flag to indicate whether the agent should report full state.
	// If true, the agent should report all state information.
	// More details, see https://github.com/open-telemetry/opamp-spec/blob/main/specification.md#servertoagentflags
	ReportFullState bool
	// RemoteConfigUpdated is a flag to indicate that remote config has been updated.
	RemoteConfigUpdated bool
	// RemoteConfigUpdatedHash is the hash of the updated remote config.
	RemoteConfigUpdatedHash vo.Hash
	// CreatedAt is the time the command was created.
	CreatedAt time.Time
	// CreatedBy is the user who created the command.
	CreatedBy string
}

// AgentSpec is a domain model to control opamp agent spec.
// AgentSpec is a domain model to control opamp agent spec.
type AgentSpec struct {
	RemoteConfig RemoteConfig
}

// AgentComponentHealth is a domain model to control opamp agent component health.
type AgentComponentHealth struct {
	// Set to true if the Agent is up and healthy.
	Healthy bool

	// Timestamp since the Agent is up
	StartTime time.Time

	// Human-readable error message if the Agent is in erroneous state. SHOULD be set when healthy==false.
	LastError string

	// Component status represented as a string.
	// The status values are defined by agent-specific semantics and not at the protocol level.
	Status string

	// The time when the component status was observed.
	StatusTime time.Time

	// A map to store more granular, sub-component health.
	// It can nest as deeply as needed to describe the underlying system.
	ComponentHealthMap map[string]AgentComponentHealth
}

// AgentEffectiveConfig is the effective configuration of the agent.
type AgentEffectiveConfig struct {
	ConfigMap AgentConfigMap
}

// AgentConfigMap is a map of configuration files.
type AgentConfigMap struct {
	// The config_map field of the AgentConfigSet message is a map of configuration files, where keys are file names.
	ConfigMap map[string]AgentConfigFile
}

// AgentConfigFile is a configuration file.
type AgentConfigFile struct {
	// The body field contains the raw bytes of the configuration file.
	// The content, format and encoding of the raw bytes is Agent type-specific and is outside the concerns of OpAMP
	// protocol.
	Body []byte

	// content_type is an optional field. It is a MIME Content-Type that describes what's contained in the body field,
	// for example "text/yaml". The content_type reported in the Effective Configuration in the Agent's status report may
	// be used for example by the Server to visualize the reported configuration nicely in a UI.
	ContentType string
}

// AgentRemoteConfigStatus is the status of the remote configuration.
type AgentRemoteConfigStatus struct {
	LastRemoteConfigHash []byte
	Status               RemoteConfigStatus
	ErrorMessage         string
}

// AgentPackageStatuses is a map of package statuses.
type AgentPackageStatuses struct {
	Packages                     map[string]AgentPackageStatus
	ServerProvidedAllPackgesHash []byte
	ErrorMessage                 string
}

// AgentPackageStatus is the status of a package.
type AgentPackageStatus struct {
	Name                 string
	AgentHasVersion      string
	AgentHasHash         []byte
	ServerOfferedVersion string
	Status               AgentPackageStatusEnum
	ErrorMessage         string
}

// AgentPackageStatusEnum is an enum that represents the status of a package.
type AgentPackageStatusEnum int32

// AgentPackageStatusEnum values
// The AgentPackageStatusEnum enum is defined in the opamp protocol.
const (
	AgentPackageStatusEnumInstalled      = 0
	AgentPackageStatusEnumInstallPending = 1
	AgentPackageStatusEnumInstalling     = 2
	AgentPackageStatusEnumInstallFailed  = 3
	AgentPackageStatusEnumDownloading    = 4
)

// AgentCustomCapabilities is a list of custom capabilities that the Agent supports.
type AgentCustomCapabilities struct {
	Capabilities []string
}

// AgentAvailableComponents is a map of available components.
type AgentAvailableComponents struct {
	Components map[string]ComponentDetails
	Hash       []byte
}

// ComponentDetails is a details of a component.
type ComponentDetails struct {
	Metadata        map[string]string
	SubComponentMap map[string]ComponentDetails
}

// ReportDescription is a method to report the description of the agent.
func (a *Agent) ReportDescription(desc *agent.Description) error {
	if desc == nil {
		return nil // No description to report
	}

	a.Metadata.Description = *desc

	return nil
}

// ReportComponentHealth is a method to report the component health of the agent.
func (a *Agent) ReportComponentHealth(health *AgentComponentHealth) error {
	if health == nil {
		return nil // No health to report
	}

	a.Status.ComponentHealth = *health

	return nil
}

// ReportCapabilities is a method to report the capabilities of the agent.
func (a *Agent) ReportCapabilities(capabilities *agent.Capabilities) error {
	if capabilities == nil {
		return nil // No capabilities to report
	}

	a.Metadata.Capabilities = *capabilities

	return nil
}

// ReportEffectiveConfig is a method to report the effective configuration of the agent.
func (a *Agent) ReportEffectiveConfig(config *AgentEffectiveConfig) error {
	if config == nil {
		return nil // No effective config to report
	}

	a.Status.EffectiveConfig = *config

	return nil
}

// ReportRemoteConfigStatus is a method to report the remote configuration status of the agent.
func (a *Agent) ReportRemoteConfigStatus(status *AgentRemoteConfigStatus) error {
	if status == nil {
		return nil // No remote config status to report
	}

	if status.ErrorMessage != "" {
		a.Spec.RemoteConfig.SetLastErrorMessage(status.ErrorMessage)
	}

	a.Spec.RemoteConfig.SetStatus(
		vo.Hash(status.LastRemoteConfigHash),
		status.Status,
	)

	return nil
}

// ApplyRemoteConfig is a method to apply the remote configuration to the agent.
func (a *Agent) ApplyRemoteConfig(config any) error {
	configData, err := NewRemoteConfigData(config)
	if err != nil {
		return fmt.Errorf("failed to create remote config data: %w", err)
	}

	err = a.Spec.RemoteConfig.ApplyRemoteConfig(configData)
	if err != nil {
		return fmt.Errorf("failed to apply remote config: %w", err)
	}

	// Add command to notify agent about config change
	a.Commands.SendRemoteConfigUpdated(configData.Key, time.Now(), "system")

	return nil
}

// ReportPackageStatuses is a method to report the package statuses of the agent.
func (a *Agent) ReportPackageStatuses(status *AgentPackageStatuses) error {
	if status == nil {
		return nil // No package statuses to report
	}

	a.Status.PackageStatuses = *status

	return nil
}

// ReportCustomCapabilities is a method to report the custom capabilities of the agent.
func (a *Agent) ReportCustomCapabilities(capabilities *AgentCustomCapabilities) error {
	if capabilities == nil {
		return nil // No custom capabilities to report
	}

	a.Metadata.CustomCapabilities = *capabilities

	return nil
}

// ReportAvailableComponents is a method to report the available components of the agent.
func (a *Agent) ReportAvailableComponents(availableComponents *AgentAvailableComponents) error {
	if availableComponents == nil {
		return nil // No available components to report
	}

	a.Status.AvailableComponents = *availableComponents

	return nil
}

// SetReportFullState is a method to set the report full state of the agent.
func (a *Agent) SetReportFullState(reportFullState bool, requestedAt time.Time, requestedBy string) {
	a.Commands.SendReportFullState(reportFullState, requestedAt, requestedBy)
}

// RecordLastReported updates the last communicated time and server of the agent.
func (a *Agent) RecordLastReported(by *Server, at time.Time) {
	if by != nil {
		a.Status.LastReportedTo = by
	}

	a.Status.LastReportedAt = at
}

// RemoteConfig is a struct to manage remote config.
type RemoteConfig struct {
	ConfigData       RemoteConfigData
	LastErrorMessage string
	LastModifiedAt   time.Time
}

// RemoteConfigData is a struct to manage remote config data with status.
type RemoteConfigData struct {
	Key           vo.Hash
	Status        RemoteConfigStatus
	Config        []byte
	LastUpdatedAt time.Time
}

// RemoteConfigStatus is generated from agentToServer of OpAMP.
type RemoteConfigStatus int32

// RemoteConfigStatus constants
// To manage simply, we use opamp-go's protobufs' value.
const (
	RemoteConfigStatusUnset RemoteConfigStatus = RemoteConfigStatus(
		int32(protobufs.RemoteConfigStatuses_RemoteConfigStatuses_UNSET))
	RemoteConfigStatusApplied RemoteConfigStatus = RemoteConfigStatus(
		int32(protobufs.RemoteConfigStatuses_RemoteConfigStatuses_APPLIED))
	RemoteConfigStatusApplying RemoteConfigStatus = RemoteConfigStatus(
		int32(protobufs.RemoteConfigStatuses_RemoteConfigStatuses_APPLYING))
	RemoteConfigStatusFailed RemoteConfigStatus = RemoteConfigStatus(
		int32(protobufs.RemoteConfigStatuses_RemoteConfigStatuses_FAILED))
)

// String returns the string representation of the status.
func (s RemoteConfigStatus) String() string {
	switch s {
	case RemoteConfigStatusUnset:
		return "UNSET"
	case RemoteConfigStatusApplied:
		return "APPLIED"
	case RemoteConfigStatusApplying:
		return "APPLYING"
	case RemoteConfigStatusFailed:
		return "FAILED"
	default:
		return fmt.Sprintf("UNKNOWN(%d)", int32(s))
	}
}

// NewRemoteConfig creates a new RemoteConfig instance.
func NewRemoteConfig() RemoteConfig {
	return RemoteConfig{
		ConfigData: RemoteConfigData{
			Key:           vo.Hash{},
			Status:        RemoteConfigStatusUnset,
			Config:        []byte{},
			LastUpdatedAt: time.Time{},
		},
		LastErrorMessage: "",
		LastModifiedAt:   time.Now(),
	}
}

// NewRemoteConfigData creates a new RemoteConfigData instance from config.
func NewRemoteConfigData(config any) (RemoteConfigData, error) {
	configBytes, err := yaml.Marshal(config)
	if err != nil {
		return RemoteConfigData{}, fmt.Errorf("failed to marshal config: %w", err)
	}

	hash, err := vo.NewHash(configBytes)
	if err != nil {
		return RemoteConfigData{}, fmt.Errorf("failed to create hash: %w", err)
	}

	return RemoteConfigData{
		Key:           hash,
		Status:        RemoteConfigStatusUnset,
		Config:        configBytes,
		LastUpdatedAt: time.Now(),
	}, nil
}

// RemoteConfigStatusFromOpAMP converts OpAMP status to domain model.
func RemoteConfigStatusFromOpAMP(status protobufs.RemoteConfigStatuses) RemoteConfigStatus {
	return RemoteConfigStatus(status)
}

// SetStatus sets status with key.
func (r *RemoteConfig) SetStatus(key vo.Hash, status RemoteConfigStatus) {
	r.updateLastModifiedAt()

	if r.ConfigData.Key.Equal(key) {
		r.ConfigData.Status = status
	}
}

// GetStatus gets status with key.
func (r *RemoteConfig) GetStatus(key vo.Hash) RemoteConfigStatus {
	if r.ConfigData.Key.Equal(key) {
		return r.ConfigData.Status
	}

	return RemoteConfigStatusUnset
}

// GetCurrentConfig returns the current config data.
func (r *RemoteConfig) GetCurrentConfig() RemoteConfigData {
	return r.ConfigData
}

// SetLastErrorMessage sets last error message.
func (r *RemoteConfig) SetLastErrorMessage(errorMessage string) {
	r.updateLastModifiedAt()
	r.LastErrorMessage = errorMessage
}

// ApplyRemoteConfig applies remote config.
func (r *RemoteConfig) ApplyRemoteConfig(configData RemoteConfigData) error {
	r.updateLastModifiedAt()
	r.ConfigData = configData

	return nil
}

// IsManaged returns whether the agent is managed by the server.
// An agent is considered managed if it has remote config.
func (r *RemoteConfig) IsManaged() bool {
	return !r.ConfigData.Key.IsZero()
}

// UpdateLastCommunicationInfo updates the last communication info of the agent.
func (a *Agent) UpdateLastCommunicationInfo(now time.Time, connection *Connection) {
	a.Status.Connected = true

	a.Status.LastReportedAt = now
	if connection != nil {
		a.Status.ConnectionType = connection.Type
	} else {
		a.Status.ConnectionType = ConnectionTypeUnknown
	}
}

// IsRemoteConfigSupported checks if the agent supports remote configuration.
func (a *Agent) IsRemoteConfigSupported() bool {
	return a.Metadata.Capabilities.Has(agent.AgentCapabilityAcceptsRemoteConfig)
}

// caution: inject now instead of time.Now()
func (r *RemoteConfig) updateLastModifiedAt() {
	r.LastModifiedAt = time.Now()
}

// HasRemoteConfig checks if the agent has remote configuration to apply.
func (a *Agent) HasRemoteConfig() bool {
	return len(a.Commands.Commands) > 0 && a.IsRemoteConfigSupported()
}

// SetCondition sets or updates a condition in the agent's status.
func (a *Agent) SetCondition(conditionType AgentConditionType, status AgentConditionStatus, triggeredBy, message string) {
	now := time.Now()
	
	// Check if condition already exists
	for i, condition := range a.Status.Conditions {
		if condition.Type == conditionType {
			// Update existing condition only if status changed
			if condition.Status != status {
				a.Status.Conditions[i].Status = status
				a.Status.Conditions[i].LastTransitionTime = now
				a.Status.Conditions[i].Reason = triggeredBy
				a.Status.Conditions[i].Message = message
			}
			return
		}
	}
	
	// Add new condition
	a.Status.Conditions = append(a.Status.Conditions, AgentCondition{
		Type:               conditionType,
		LastTransitionTime: now,
		Status:             status,
		Reason:             triggeredBy,
		Message:            message,
	})
}

// GetCondition returns the condition of the specified type.
func (a *Agent) GetCondition(conditionType AgentConditionType) *AgentCondition {
	for _, condition := range a.Status.Conditions {
		if condition.Type == conditionType {
			return &condition
		}
	}
	return nil
}

// IsConditionTrue checks if the specified condition type is true.
func (a *Agent) IsConditionTrue(conditionType AgentConditionType) bool {
	condition := a.GetCondition(conditionType)
	return condition != nil && condition.Status == AgentConditionStatusTrue
}

// MarkConnected marks the agent as connected and updates the connection condition.
func (a *Agent) MarkConnected(triggeredBy string) {
	a.Status.Connected = true
	a.Status.LastReportedAt = time.Now()
	a.SetCondition(AgentConditionTypeConnected, AgentConditionStatusTrue, triggeredBy, "Agent connected")
}

// MarkDisconnected marks the agent as disconnected and updates the connection condition.
func (a *Agent) MarkDisconnected(triggeredBy string) {
	a.Status.Connected = false
	a.SetCondition(AgentConditionTypeConnected, AgentConditionStatusFalse, triggeredBy, "Agent disconnected")
}

// MarkHealthy marks the agent as healthy.
func (a *Agent) MarkHealthy(triggeredBy string) {
	a.SetCondition(AgentConditionTypeHealthy, AgentConditionStatusTrue, triggeredBy, "Agent is healthy")
}

// MarkUnhealthy marks the agent as unhealthy.
func (a *Agent) MarkUnhealthy(triggeredBy, reason string) {
	message := "Agent is unhealthy"
	if reason != "" {
		message = fmt.Sprintf("Agent is unhealthy: %s", reason)
	}
	a.SetCondition(AgentConditionTypeHealthy, AgentConditionStatusFalse, triggeredBy, message)
}

// MarkConfigured marks the agent as configured.
func (a *Agent) MarkConfigured(triggeredBy string) {
	a.SetCondition(AgentConditionTypeConfigured, AgentConditionStatusTrue, triggeredBy, "Agent configuration applied")
}
